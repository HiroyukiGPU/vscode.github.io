<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Language Code Typing Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            overflow: hidden;
        }

        .editor-wrapper {
            display: flex;
            height: calc(100vh - 42px);
            width: 100vw;
        }

        .line-numbers {
            background-color: #1e1e1e;
            color: #858585;
            padding: 20px 10px;
            text-align: right;
            user-select: none;
            min-width: 60px;
            border-right: 1px solid #2d2d30;
            font-size: 14px;
            line-height: 21px;
            overflow-y: auto;
            overflow-x: hidden;
            white-space: pre;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .line-numbers::-webkit-scrollbar {
            width: 0;
            display: none;
        }

        .code-area {
            flex: 1;
            background-color: #1e1e1e;
            padding: 20px;
            overflow-y: auto;
            overflow-x: auto;
            font-size: 14px;
            line-height: 21px;
            white-space: pre;
            position: relative;
            tab-size: 4;
            -moz-tab-size: 4;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .code-area::-webkit-scrollbar {
            width: 0;
            height: 0;
            display: none;
        }

        .cursor {
            display: inline-block;
            width: 2px;
            height: 18px;
            background-color: #ffffff;
            animation: blink 1s infinite;
            position: relative;
            top: 3px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Syntax Highlighting */
        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; font-style: italic; }
        .function { color: #dcdcaa; }
        .number { color: #b5cea8; }
        .class-name { color: #4ec9b0; }
        .property { color: #9cdcfe; }
        .operator { color: #d4d4d4; }
        .punctuation { color: #d4d4d4; }
        .auto-complete { color: #6e6e6e; }
        
        /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d30 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .loading-content {
            text-align: center;
            color: #d4d4d4;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            margin: 0 auto 30px;
            border: 4px solid #2d2d30;
            border-top: 4px solid #569cd6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-title {
            font-size: 24px;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #569cd6, #4ec9b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .loading-text {
            font-size: 14px;
            color: #858585;
            margin-bottom: 25px;
            min-height: 20px;
        }
        
        .loading-bar {
            width: 300px;
            height: 4px;
            background-color: #2d2d30;
            border-radius: 2px;
            overflow: hidden;
            margin: 0 auto;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #569cd6, #4ec9b0);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <h2 class="loading-title">Detecting Code Files...</h2>
            <p class="loading-text" id="loadingText">Scanning for files...</p>
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
        </div>
    </div>
    
    <div class="editor-wrapper">
        <div class="line-numbers" id="lineNumbers">1</div>
        <div class="code-area" id="codeArea"></div>
    </div>

    <script>
        // è‡ªå‹•æ¤œå‡ºã•ã‚Œã‚‹æ‹¡å¼µå­ãƒªã‚¹ãƒˆ
        const possibleExtensions = [
            'py', 'java', 'js', 'c', 'cpp', 'cs', 'php', 'kt', 'rb', 'go',
            'sql', 'ts', 'sh', 'rs', 'dart', 'asm', 'swift', 'r', 'vb',
            'html', 'css', 'pl', 'd', 'txt'
        ];
        
        let codeFiles = []; // å‹•çš„ã«æ¤œå‡ºã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆ
        let currentFileIndex = 0;
        let fullCode = '';
        let currentIndex = 0;
        let typingSpeed = 20; // ãƒŸãƒªç§’ï¼ˆ20ms = 50æ–‡å­—/ç§’ï¼‰
        let typingInterval = null;
        let displayedCode = ''; // å®Ÿéš›ã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ï¼ˆè‡ªå‹•è£œå®Œå«ã‚€ï¼‰
        let autoCompletedChars = 0; // è‡ªå‹•è£œå®Œã§è¿½åŠ ã•ã‚ŒãŸæ–‡å­—æ•°
        let currentLanguage = 'javascript'; // ç¾åœ¨ã®è¨€èª
        
        // ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‹ã‚‰è¨€èªã‚’åˆ¤å®š
        function detectLanguage(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const langMap = {
                'py': 'python',
                'java': 'java',
                'js': 'javascript',
                'c': 'c',
                'cpp': 'cpp',
                'cc': 'cpp',
                'cxx': 'cpp',
                'cs': 'csharp',
                'php': 'php',
                'kt': 'kotlin',
                'rb': 'ruby',
                'go': 'go',
                'sql': 'sql',
                'ts': 'typescript',
                'sh': 'shell',
                'bash': 'shell',
                'rs': 'rust',
                'dart': 'dart',
                'asm': 'assembly',
                's': 'assembly',
                'swift': 'swift',
                'r': 'r',
                'vb': 'vb',
                'html': 'html',
                'htm': 'html',
                'css': 'css',
                'pl': 'perl',
                'd': 'd'
            };
            return langMap[ext] || 'javascript';
        }

        // ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        async function loadCurrentFile() {
            const fileName = codeFiles[currentFileIndex];
            currentLanguage = detectLanguage(fileName);
            console.log(`ğŸ“‚ Loading file: ${fileName} (${currentFileIndex + 1}/${codeFiles.length}) - Language: ${currentLanguage}`);
            
            try {
                const response = await fetch(fileName);
                if (!response.ok) {
                    throw new Error(`File not found: ${fileName}`);
                }
                
                let code = await response.text();
                
                // è¡Œé ­ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’ã‚¿ãƒ–ã«å¤‰æ›ï¼ˆ2ã‚¹ãƒšãƒ¼ã‚¹ã€4ã‚¹ãƒšãƒ¼ã‚¹ã€8ã‚¹ãƒšãƒ¼ã‚¹ç­‰ï¼‰
                code = code.split('\n').map(line => {
                    // è¡Œé ­ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’æ•°ãˆã‚‹
                    const match = line.match(/^( +)/);
                    if (match) {
                        const spaces = match[1].length;
                        // 2ã‚¹ãƒšãƒ¼ã‚¹ã”ã¨ã«1ã‚¿ãƒ–ã«å¤‰æ›ï¼ˆã¾ãŸã¯4ã‚¹ãƒšãƒ¼ã‚¹ã”ã¨ï¼‰
                        const tabs = '\t'.repeat(Math.floor(spaces / 2));
                        const remainingSpaces = ' '.repeat(spaces % 2);
                        return tabs + remainingSpaces + line.substring(spaces);
                    }
                    return line;
                }).join('\n');
                
                fullCode = code;
                currentIndex = 0;
                displayedCode = '';
                autoCompletedChars = 0;
                
                startTyping();
            } catch (error) {
                console.error(`ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${fileName}`, error);
                fullCode = `// ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${fileName}\n// ãƒ•ã‚¡ã‚¤ãƒ«ãŒåŒã˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`;
                currentIndex = 0;
                displayedCode = '';
                autoCompletedChars = 0;
                
                startTyping();
            }
        }
        
        // æ¬¡ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ç§»å‹•
        function loadNextFile() {
            currentFileIndex = (currentFileIndex + 1) % codeFiles.length;
            console.log(`â¡ï¸ Moving to next file (${currentFileIndex + 1}/${codeFiles.length})`);
            
            // ç”»é¢ã‚’ã‚¯ãƒªã‚¢
            document.getElementById('codeArea').innerHTML = '';
            document.getElementById('lineNumbers').textContent = '1';
            
            // å°‘ã—å¾…ã£ã¦ã‹ã‚‰æ¬¡ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
            setTimeout(() => {
                loadCurrentFile();
            }, 1000);
        }
        
        // å¯¾å¿œã™ã‚‹é–‰ã˜æ‹¬å¼§ã‚’å–å¾—
        function getClosingBracket(char) {
            const brackets = {
                '(': ')',
                '{': '}',
                '[': ']'
            };
            return brackets[char] || null;
        }
        
        // å„è¨€èªã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å–å¾—
        function getLanguageKeywords(lang) {
            const keywords = {
                javascript: 'class|constructor|function|const|let|var|if|else|for|while|return|new|this|try|catch|throw|async|await|import|export|from|default|extends|static|get|set|case|switch|break|continue|do|typeof|instanceof|delete|void|yield|in|of',
                typescript: 'class|constructor|function|const|let|var|if|else|for|while|return|new|this|try|catch|throw|async|await|import|export|from|default|extends|static|get|set|case|switch|break|continue|do|typeof|instanceof|delete|void|yield|in|of|interface|type|enum|namespace|abstract|implements|private|public|protected|readonly',
                python: 'def|class|if|elif|else|for|while|return|import|from|as|try|except|finally|raise|with|lambda|yield|async|await|pass|break|continue|and|or|not|in|is|None|True|False|self',
                java: 'class|interface|extends|implements|public|private|protected|static|final|abstract|void|int|long|short|byte|float|double|boolean|char|String|if|else|for|while|do|switch|case|return|new|this|super|try|catch|finally|throw|throws|import|package|synchronized|volatile|transient',
                c: 'int|long|short|char|float|double|void|unsigned|signed|struct|union|enum|typedef|sizeof|if|else|for|while|do|switch|case|return|break|continue|goto|static|extern|const|volatile|auto|register',
                cpp: 'int|long|short|char|float|double|void|unsigned|signed|bool|class|struct|union|enum|namespace|template|typename|public|private|protected|virtual|friend|operator|new|delete|this|nullptr|if|else|for|while|do|switch|case|return|break|continue|try|catch|throw|const|static|extern|inline|constexpr|auto',
                csharp: 'class|interface|struct|enum|namespace|using|public|private|protected|internal|static|readonly|const|virtual|override|abstract|sealed|partial|void|int|long|short|byte|float|double|decimal|bool|char|string|object|var|if|else|for|foreach|while|do|switch|case|return|new|this|base|try|catch|finally|throw|async|await',
                php: 'class|interface|trait|extends|implements|public|private|protected|static|final|abstract|function|if|else|elseif|for|foreach|while|do|switch|case|return|new|this|parent|self|try|catch|finally|throw|use|namespace|echo|print|include|require|array|null|true|false',
                kotlin: 'class|interface|object|fun|val|var|if|else|when|for|while|do|return|this|super|null|true|false|is|in|as|try|catch|finally|throw|public|private|protected|internal|open|abstract|override|sealed|data|companion|init',
                ruby: 'class|module|def|if|elsif|else|unless|case|when|for|while|until|do|end|return|yield|self|super|true|false|nil|begin|rescue|ensure|raise|and|or|not|in',
                go: 'func|var|const|type|struct|interface|package|import|if|else|for|range|switch|case|return|defer|go|chan|select|break|continue|fallthrough|goto|true|false|nil',
                sql: 'SELECT|FROM|WHERE|JOIN|INNER|LEFT|RIGHT|OUTER|ON|AND|OR|NOT|IN|LIKE|BETWEEN|ORDER|BY|GROUP|HAVING|INSERT|INTO|VALUES|UPDATE|SET|DELETE|CREATE|TABLE|ALTER|DROP|INDEX|VIEW|DATABASE|PRIMARY|KEY|FOREIGN|REFERENCES|NULL|DEFAULT|CONSTRAINT|UNION|DISTINCT|COUNT|SUM|AVG|MIN|MAX',
                shell: 'if|then|else|elif|fi|case|esac|for|while|until|do|done|function|return|exit|break|continue|echo|printf|read|export|local|declare|set|unset|true|false',
                rust: 'fn|let|mut|const|static|if|else|match|loop|while|for|in|return|break|continue|struct|enum|impl|trait|type|where|pub|mod|use|crate|self|super|async|await|move|ref|true|false|None|Some',
                dart: 'class|interface|extends|implements|mixin|abstract|enum|void|var|final|const|if|else|for|while|do|switch|case|return|new|this|super|try|catch|finally|throw|rethrow|async|await|yield|import|export|library|part|true|false|null',
                assembly: 'mov|push|pop|add|sub|mul|div|inc|dec|jmp|je|jne|jg|jl|call|ret|int|lea|cmp|test|and|or|xor|not|shl|shr|nop',
                swift: 'class|struct|enum|protocol|extension|func|var|let|if|else|guard|switch|case|for|while|repeat|return|break|continue|fallthrough|self|super|init|deinit|true|false|nil|import|public|private|internal|fileprivate|static|mutating|throws|try|catch|async|await',
                r: 'function|if|else|for|while|repeat|break|next|return|in|TRUE|FALSE|NULL|NA|NaN|Inf|library|require|source',
                vb: 'Class|Module|Function|Sub|If|Then|Else|ElseIf|End|For|To|Step|Next|While|Do|Loop|Until|Select|Case|Return|New|Me|MyBase|True|False|Nothing|Public|Private|Protected|Friend|Shared|Dim|As|Integer|String|Boolean|Double|Imports|Namespace',
                html: 'DOCTYPE|html|head|body|title|meta|link|script|style|div|span|a|img|ul|ol|li|table|tr|td|th|form|input|button|select|option|textarea|label|header|footer|nav|section|article|aside|main|figure|figcaption',
                css: 'absolute|animation|background|border|bottom|box|calc|center|class|color|content|display|fixed|flex|float|font|grid|height|hover|id|inline|left|margin|max|min|opacity|padding|position|relative|right|rotate|scale|shadow|static|text|top|transform|transition|translate|width',
                perl: 'if|else|elsif|unless|while|until|for|foreach|do|sub|my|our|local|return|use|require|package|new|bless|shift|unshift|push|pop|keys|values|each|grep|map|sort|split|join|print|say|chomp|chop|defined|undef',
                d: 'import|module|class|struct|interface|enum|union|function|void|int|float|double|char|bool|if|else|for|while|do|foreach|switch|case|break|continue|return|auto|const|immutable|pure|nothrow|ref|out|in|body|unittest|assert|static|final|override|abstract|public|private|protected|package'
            };
            return keywords[lang] || keywords.javascript;
        }
        
        // å„è¨€èªã®ã‚³ãƒ¡ãƒ³ãƒˆæ§‹æ–‡ã‚’å–å¾—
        function getCommentPatterns(lang) {
            const patterns = {
                python: { line: '#', block: null },
                ruby: { line: '#', block: null },
                shell: { line: '#', block: null },
                r: { line: '#', block: null },
                sql: { line: '--', block: { start: '/\\*', end: '\\*/' } },
                vb: { line: "'", block: null },
                assembly: { line: ';', block: null },
                perl: { line: '#', block: { start: '=begin', end: '=cut' } },
                html: { line: null, block: { start: '<!--', end: '-->' } },
                css: { line: null, block: { start: '/\\*', end: '\\*/' } },
                d: { line: '//', block: { start: '/\\*', end: '\\*/' } }
            };
            return patterns[lang] || { line: '//', block: { start: '/\\*', end: '\\*/' } };
        }

        // ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        function highlightSyntax(code) {
            // TABã‚’ä¿è­·ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
            const tabPlaceholder = '___TAB___';
            code = code.replace(/\t/g, tabPlaceholder);
            
            // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å‡¦ç†ï¼ˆæœ€åˆã«è¡Œã†ï¼‰
            code = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            
            // ä¸€æ™‚çš„ãªãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’ä½¿ç”¨
            const placeholder = '___PLACEHOLDER___';
            const protectedParts = [];
            
            // ã‚³ãƒ¡ãƒ³ãƒˆæ§‹æ–‡ã‚’å–å¾—
            const commentPatterns = getCommentPatterns(currentLanguage);
            
            // ã‚³ãƒ¡ãƒ³ãƒˆã‚’ä¿è­·
            if (commentPatterns.block) {
                // ãƒ–ãƒ­ãƒƒã‚¯ã‚³ãƒ¡ãƒ³ãƒˆ
                const blockPattern = new RegExp(`${commentPatterns.block.start}[\\s\\S]*?${commentPatterns.block.end}`, 'gm');
                code = code.replace(blockPattern, (match) => {
                    const index = protectedParts.length;
                    protectedParts.push(`<span class="comment">${match}</span>`);
                    return `${placeholder}${index}${placeholder}`;
                });
            }
            
            // è¡Œã‚³ãƒ¡ãƒ³ãƒˆ
            if (commentPatterns.line) {
                const lineCommentEscaped = commentPatterns.line.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const linePattern = new RegExp(`${lineCommentEscaped}.*?$`, 'gm');
                code = code.replace(linePattern, (match) => {
                    const index = protectedParts.length;
                    protectedParts.push(`<span class="comment">${match}</span>`);
                    return `${placeholder}${index}${placeholder}`;
                });
            }
            
            // æ–‡å­—åˆ—ã‚’ä¿è­·ï¼ˆè¨€èªã«å¿œã˜ã¦èª¿æ•´ï¼‰
            let stringPattern;
            if (currentLanguage === 'python' || currentLanguage === 'ruby') {
                // Python/Rubyã¯'ã€"ã€'''ã€"""ã‚’ã‚µãƒãƒ¼ãƒˆ
                stringPattern = /('''[\s\S]*?'''|"""[\s\S]*?"""|'(?:[^'\\]|\\.)*?'|"(?:[^"\\]|\\.)*?")/g;
            } else if (currentLanguage === 'php') {
                // PHPã¯$ã‚’å«ã‚€å¤‰æ•°ã‚‚ã‚µãƒãƒ¼ãƒˆ
                stringPattern = /('(?:[^'\\]|\\.)*?'|"(?:[^"\\]|\\.)*?")/g;
            } else {
                // ä¸€èˆ¬çš„ãªæ–‡å­—åˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³
                stringPattern = /(['"`])((?:\\.|(?!\1)[^\\])*?)\1/g;
            }
            
            code = code.replace(stringPattern, (match) => {
                const index = protectedParts.length;
                protectedParts.push(`<span class="string">${match}</span>`);
                return `${placeholder}${index}${placeholder}`;
            });
            
            // è¨€èªã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            const keywords = getLanguageKeywords(currentLanguage);
            const keywordPattern = new RegExp(`\\b(${keywords})\\b`, 'g');
            code = code.replace(keywordPattern, '<span class="keyword">$1</span>');
            
            // æ•°å€¤
            code = code.replace(/\b(\d+\.?\d*|\.\d+|0x[0-9a-fA-F]+)\b/g, '<span class="number">$1</span>');
            
            // é–¢æ•°åï¼ˆè¨€èªã«å¿œã˜ã¦èª¿æ•´ï¼‰
            if (currentLanguage === 'python') {
                code = code.replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g, '<span class="function">$1</span>(');
            } else if (currentLanguage === 'assembly') {
                // ã‚¢ã‚»ãƒ³ãƒ–ãƒªã¯ç‰¹åˆ¥ãªå‡¦ç†ä¸è¦
            } else {
                code = code.replace(/\b([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(/g, '<span class="function">$1</span>(');
            }
            
            // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ï¼ˆè¨€èªã«å¿œã˜ã¦ï¼‰
            if (currentLanguage !== 'assembly' && currentLanguage !== 'sql') {
                code = code.replace(/\.([a-zA-Z_$][a-zA-Z0-9_$]*)/g, '.<span class="property">$1</span>');
            }
            
            // ä¿è­·ã•ã‚ŒãŸéƒ¨åˆ†ã‚’å¾©å…ƒ
            code = code.replace(new RegExp(`${placeholder}(\\d+)${placeholder}`, 'g'), (match, index) => {
                return protectedParts[parseInt(index)];
            });
            
            // TABã‚’å¾©å…ƒ
            code = code.replace(new RegExp(tabPlaceholder, 'g'), '\t');
            
            return code;
        }

        // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        function typeCharacter() {
            if (currentIndex >= fullCode.length) {
                clearInterval(typingInterval);
                console.log('âœ… File completed! Moving to next file...');
                // ãƒ•ã‚¡ã‚¤ãƒ«ãŒçµ‚ã‚ã£ãŸã‚‰æ¬¡ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ç§»å‹•
                loadNextFile();
                return;
            }

            // æ¬¡ã®æ–‡å­—ã‚’å–å¾—
            const nextChar = fullCode[currentIndex];
            currentIndex++;
            
            // è‡ªå‹•è£œå®Œã§è¿½åŠ ã•ã‚ŒãŸæ–‡å­—ãŒã‚ã‚‹å ´åˆã®å‡¦ç†
            if (autoCompletedChars > 0) {
                // è‡ªå‹•è£œå®Œã•ã‚ŒãŸé–‰ã˜æ‹¬å¼§ãŒã‚ã‚‹ã‹ç¢ºèª
                const autoCompletedPart = displayedCode.slice(-autoCompletedChars);
                
                // æ¬¡ã®æ–‡å­—ãŒè‡ªå‹•è£œå®Œã•ã‚ŒãŸæœ€åˆã®æ–‡å­—ã¨ä¸€è‡´ã™ã‚‹å ´åˆ
                // ï¼ˆã¤ã¾ã‚Šé–‰ã˜æ‹¬å¼§ã‚’å…¥åŠ›ã™ã‚‹å ´åˆï¼‰
                if (nextChar === autoCompletedPart[0]) {
                    // è‡ªå‹•è£œå®Œéƒ¨åˆ†ã‚’1æ–‡å­—å‰Šé™¤
                    displayedCode = displayedCode.slice(0, -autoCompletedChars) + nextChar + autoCompletedPart.substring(1);
                    autoCompletedChars--;
                } else {
                    // ä»–ã®æ–‡å­—ã‚’å…¥åŠ›ã™ã‚‹å ´åˆã¯è‡ªå‹•è£œå®Œã‚’å…¨å‰Šé™¤
                    displayedCode = displayedCode.slice(0, -autoCompletedChars);
                    autoCompletedChars = 0;
                    displayedCode += nextChar;
                }
            } else {
                // è¡¨ç¤ºç”¨ã‚³ãƒ¼ãƒ‰ã«è¿½åŠ 
                displayedCode += nextChar;
            }
            
            // é–‹ãæ‹¬å¼§ã®å ´åˆã¯å¯¾å¿œã™ã‚‹é–‰ã˜æ‹¬å¼§ã‚’è‡ªå‹•è¿½åŠ 
            const closingBracket = getClosingBracket(nextChar);
            
            if (closingBracket && autoCompletedChars === 0) {
                console.log('ğŸ”· Auto-completing:', nextChar, 'â†’', closingBracket);
                displayedCode += closingBracket;
                autoCompletedChars = 1;
            }

            const codeArea = document.getElementById('codeArea');
            const lineNumbers = document.getElementById('lineNumbers');
            
            // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’è¨ˆç®—ï¼ˆè‡ªå‹•è£œå®Œã•ã‚ŒãŸæ–‡å­—ã®å‰ï¼‰
            let codeBeforeCursor = displayedCode;
            let codeAfterCursor = '';
            
            if (autoCompletedChars > 0) {
                codeBeforeCursor = displayedCode.slice(0, -autoCompletedChars);
                codeAfterCursor = displayedCode.slice(-autoCompletedChars);
            }
            
            // ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’é©ç”¨ã—ã¦è¡¨ç¤º
            const highlightedBefore = highlightSyntax(codeBeforeCursor);
            let highlightedAfter = '';
            if (codeAfterCursor) {
                // è‡ªå‹•è£œå®Œéƒ¨åˆ†ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ã¦ç°è‰²ã§è¡¨ç¤º
                const escapedAfter = codeAfterCursor.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                highlightedAfter = '<span class="auto-complete">' + escapedAfter + '</span>';
            }
            codeArea.innerHTML = highlightedBefore + '<span class="cursor"></span>' + highlightedAfter;

            // è¡Œç•ªå·ã‚’æ›´æ–°ï¼ˆå…ƒã®ã‚³ãƒ¼ãƒ‰ã®è¡Œæ•°ã§ï¼‰
            updateLineNumbers(fullCode.substring(0, currentIndex));

            // è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼ˆè¡Œç•ªå·ã‚‚åŒæœŸï¼‰
            codeArea.scrollTop = codeArea.scrollHeight;
            lineNumbers.scrollTop = lineNumbers.scrollHeight;
        }

        // è¡Œç•ªå·ã‚’æ›´æ–°
        function updateLineNumbers(text) {
            const lines = text.split('\n');
            const currentLine = lines.length;
            
            const lineNumbers = document.getElementById('lineNumbers');
            let lineNumbersHtml = '';
            for (let i = 1; i <= currentLine; i++) {
                lineNumbersHtml += i + '\n';
            }
            lineNumbers.textContent = lineNumbersHtml;
        }

        // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°é–‹å§‹
        function startTyping() {
            if (typingInterval) {
                clearInterval(typingInterval);
            }
            typingInterval = setInterval(typeCharacter, typingSpeed);
        }

        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åŒæœŸã‚’è¨­å®š
        function setupScrollSync() {
            const codeArea = document.getElementById('codeArea');
            const lineNumbers = document.getElementById('lineNumbers');
            
            // ã‚³ãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ãŒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã•ã‚ŒãŸã‚‰è¡Œç•ªå·ã‚‚åŒæœŸ
            codeArea.addEventListener('scroll', () => {
                lineNumbers.scrollTop = codeArea.scrollTop;
            });
        }
        
        // é…åˆ—ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹é–¢æ•°
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’æ›´æ–°
        function updateLoadingProgress(percent, text) {
            const loadingText = document.getElementById('loadingText');
            const loadingProgress = document.getElementById('loadingProgress');
            
            if (loadingText) loadingText.textContent = text;
            if (loadingProgress) loadingProgress.style.width = percent + '%';
        }
        
        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’éè¡¨ç¤º
        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }
        }
        
        // ä¸¦åˆ—ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡ºï¼ˆé«˜é€ŸåŒ–ï¼‰
        async function detectNumberedFiles() {
            console.log('ğŸ” æ•°å­—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•æ¤œå‡ºä¸­...');
            updateLoadingProgress(10, 'Checking for random mode...');
            
            // 0.txtã®å­˜åœ¨ç¢ºèªï¼ˆãƒ©ãƒ³ãƒ€ãƒ åŒ–ãƒ•ãƒ©ã‚°ï¼‰
            let randomizeOrder = false;
            try {
                const response = await fetch('0.txt', { method: 'HEAD' });
                if (response.ok) {
                    randomizeOrder = true;
                    console.log('ğŸ² 0.txtãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ - ãƒ©ãƒ³ãƒ€ãƒ é †ã§è¡¨ç¤ºã—ã¾ã™');
                }
            } catch (error) {
                // 0.txtãŒãªã„å ´åˆã¯é€šå¸¸é †
            }
            
            updateLoadingProgress(20, 'Scanning files in parallel...');
            
            // ä¸¦åˆ—æ¤œå‡ºï¼ˆ1ï½50ã¾ã§ä¸€æ°—ã«ãƒã‚§ãƒƒã‚¯ï¼‰
            const maxFileNumber = 50;
            const checkPromises = [];
            
            for (let fileNumber = 1; fileNumber <= maxFileNumber; fileNumber++) {
                const promise = (async (num) => {
                    // å„æ‹¡å¼µå­ã‚’è©¦ã™
                    for (const ext of possibleExtensions) {
                        const filename = `${num}.${ext}`;
                        
                        try {
                            const response = await fetch(filename, { method: 'HEAD' });
                            if (response.ok) {
                                return { number: num, filename };
                            }
                        } catch (error) {
                            // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                        }
                    }
                    return null;
                })(fileNumber);
                
                checkPromises.push(promise);
            }
            
            updateLoadingProgress(40, 'Processing results...');
            
            // ã™ã¹ã¦ã®çµæœã‚’å¾…ã¤
            const results = await Promise.all(checkPromises);
            
            updateLoadingProgress(60, 'Sorting files...');
            
            // nullã‚’é™¤å¤–ã—ã¦ã‚½ãƒ¼ãƒˆ
            const detectedFiles = results
                .filter(result => result !== null)
                .sort((a, b) => a.number - b.number)
                .map(result => result.filename);
            
            updateLoadingProgress(80, `Found ${detectedFiles.length} files...`);
            
            if (detectedFiles.length === 0) {
                console.error('âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
                updateLoadingProgress(100, 'No files found!');
                alert('è¡¨ç¤ºã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n1.py, 2.java, 3.js ãªã©ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é…ç½®ã—ã¦ãã ã•ã„ã€‚');
                return false;
            }
            
            console.log(`âœ“ ${detectedFiles.length}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡ºã—ã¾ã—ãŸ:`, detectedFiles);
            
            // 0.txtãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ãƒ©ãƒ³ãƒ€ãƒ ã«ä¸¦ã³æ›¿ãˆ
            if (randomizeOrder) {
                updateLoadingProgress(90, 'Randomizing order...');
                codeFiles = shuffleArray(detectedFiles);
                console.log(`ğŸ² ãƒ©ãƒ³ãƒ€ãƒ é †ã«ä¸¦ã³æ›¿ãˆã¾ã—ãŸ:`, codeFiles);
            } else {
                codeFiles = detectedFiles;
            }
            
            updateLoadingProgress(100, 'Ready to start!');
            
            return true;
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«é–‹å§‹
        window.addEventListener('load', async () => {
            setupScrollSync();
            
            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•æ¤œå‡º
            const filesDetected = await detectNumberedFiles();
            
            if (filesDetected) {
                // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã‚’éè¡¨ç¤º
                setTimeout(() => {
                    hideLoadingScreen();
                    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ãŒæ¶ˆãˆã¦ã‹ã‚‰æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
                    setTimeout(() => {
                        loadCurrentFile();
                    }, 300);
                }, 500);
            } else {
                hideLoadingScreen();
            }
        });
    </script>
</body>
</html>

